# mech_battleship

# 講義資料からの抜粋

## 5.2 演習用プログラム

ITC-LMS から演習用のプログラムをダウンロードし，ホームディレクトリに移動させた上で解凍する．
次に解凍したディレクトリ (bship) に移動し，master・sample・players で構成されていることを確認する．
「~/」はホームディレクトリ（「/home/mech-user/」）という 意味．
```
$ mv␣~/Downloads/bship.zip␣~/bship.zip
bship.zip を Downloads ディレクトリからホームディレクトリへ移動

$ cd カレントディレクトリをホームディレクトリにする

$ unzip␣bship.zip bship を解凍

$ cd␣bship カレントディレクトリを bship にする

$ ls bship の中身を確認する
```

master players sample という文字が出てくれば OK．
次にパーミッションを設定する ( 「-R」はディレクトリを再帰的に変更するオプション)．
```
$ chmod␣ -R␣755␣~/bship/
```
上記のコマンドでは，ホームディレクトリ下の「bship」ディレクトリ下のファイルのパーミッションを設定．

動作確認しよう！ 表示されたウィンドウにおいて[run]を押せば自動で対戦が進む．
表示が固まってしまうときは，[1]を押してから[run]するとよい．
または，[step]で 1 手ずつ表示することができる．
終わったら[quit]を押して終了する．
```
$ cd␣players ディレクトリ players に移動する
$ ./match.sh シェルスクリプト match.sh を実行する
```

-------ここまでできたら，本日の演習は終了！ 以下は次回の先取り-------
### 動作確認スクリプトの内容
match.sh の内容は下記のとおり．
ピリオド 1 つはカレントディレクトリ，ピリオド 2 つは親ディレクトリを表す．
スクリプトではなく端末に直接入力するときには sleep は必要ない．
```
../master/master␣
-a␣& 対戦 GUI が立ち上がる
sleep␣1 1 秒待つ
../sample/random␣& 一つ目の戦略プログラムをエントリーする
sleep␣1 1 秒待つ
../sample/sweep␣& 二つ目の戦略プログラムをエントリーする
```
### 自分の作成した戦略プログラムで対戦する
```
$ make プログラムをコンパイルする
```
プログラムをコンパイルすると，プログラム player ができる．
これが自分の戦略プログラムである．
match.sh を書き換えて，「../sample/sweep␣&」 ではなく 「./player␣&」 とすれば，自分のプログラムで対戦できる．
提出するプログラム名は player.c とする．
ファイル名を変更しないこと

## バトルシップ対戦システムの概要
本演習での対戦システムは， master と二つの player からなる．

master から player への通信には問い合わせと通知がある．
問い合わせは player からの返答を必要とし，通知は返答を必
要としない．
問い合わせには，プログラム名，戦艦の配置，攻撃位置の 3 種類がある．
対戦の始めにプログラム名と戦艦の配置が一度ずつ聞かれ，その後は毎回攻撃位置を聞かれる．

通知には攻撃結果の通知と終了信号がある．
攻撃位置の問い合わせに応えると，攻撃結果が通知される．
終了信号は対戦が終了したときに通知される．

### コンテストのルール
提出されたプログラムを用いて，受講者全員の総当たり戦を行う．
同じ相手とは先攻と後攻で 2 回対戦する．
順位は勝率で決め，同率の場合は平均ラウンド数の低い方を勝ちとする．
MY_NAME が「8 桁の学生証番号」でないと不参加扱いとなる．
配置ルールを破ると負けとなる．
また，一手につき 25 秒を超えると負けとなる．

### player.c の解説
冒頭の #include で始まるヘッダファイルのインクルードは，この演習では変更しない．
その次に MY_NAME と DEPLOYMENT を定義している．
MY_NAME は 8 桁の学生証番号とする．
DEPLOYMENT は自陣の配置を表す文字列である（提出時には変更すること）．
DEPLOYMENT の最後にはスペースが 1 つ必要である．
いよいよプログラムの中身であるが，まずファイルの最後にある main 関数を見てみると，通信の接続および切断の他には handle_messages しか呼ばれていないことがわかる．
関数 handle_messages は， master からの受信内容に応じて返答などを行う関数である．
while (TRUE)によるループになっている．
ループの中ではまず receive_from_ref(line) によって変数 line に master からの受信内容を読み込む．
次に，if else 文を用いて，line の内容に応じた処理を行う．
関数 message_has_type は，受信した内容がどのタイプのメッセージであるかを調べるためのものである．
1. 受信したメッセージのタイプが"name?"であれば，respond_with_name()を呼ぶ．
関数respond_with_name は master に文字列 MY_NAME を返答する．
2. 受信したメッセージのタイプが"deployment?"であれば， respond_with_deployment()を呼ぶ．
関数respond_with_ deployment は master に文字列 DEPLOYMENT を返答する．
3. 受信したメッセージのタイプが"shot?"であれば，respond_with_shot()を呼ぶ．
関数 respond_with_shot は master に攻撃位置を表す文字列を返答する．
この関数の中で，変 数 x および y がそれぞれ攻撃位置の x 座標および y 座標であり，これをどう決めるか が勝敗を左右する．
4. 受信したメッセージのタイプが"shot-result:"であれば， printf("%s", line); によりメッセージをそのまま表示している．
この状態では表示しているだけで活用していない．
強いプログラムを作るためには，攻撃の結果をいかに次に活かすかが重要である．
受信したメッセージのタイプが"end:"であれば，ループを抜けて終了する．
### サンプルプログラム sweep と ex1 を対戦させよう！
```
$ make
$ ../master/master␣–a␣&
$ ./ex1␣&
12
$ ../sample/sweep␣&
```
（match.sh を書き換えて，実行してもよい．）
必ず負ける…なぜだろうか？
課題プログラム ex1.c をエディタで開き， respond_with_shot() を確認してみよう．
