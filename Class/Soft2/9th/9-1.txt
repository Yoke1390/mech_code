# 1-1
print_bit()関数がintで定義されていたがreturnがなかったため、voidに変更した。
学生証番号03-240236のうち、u1を24とし、u2を36としてu1-u2を計算した。

/* test-minus.c */
#include <stdio.h>

void print_bit(unsigned char s) {
  int i;
  printf("0x%02x : ", s);
  for (i = 0; i < 8; i++) {
    printf("%c", ((0x80) & s) ? '1' : '0');
    s = s << 1;
  }
  printf("\n");
}

int main(int argc, char *argv[]) {
  int i;
  unsigned char u1, u2, u3;
  u1 = 24;
  printf("u1 = ");
  print_bit(u1);
  printf("u1 = %d\n", u1);
  // 2's complement
  u2 = (0xff ^ 36) + 0x01;
  printf("u2 = ");
  print_bit(u2);
  printf("u2 = %d\n", u2);
  printf("u2 = %d\n", (char)u2);
  u3 = u1 + u2;
  printf("u3 = ");
  print_bit(u3);
  printf("u3 = %d\n", u3);
  printf("u3 = %d\n", (char)u3);
}

$ gcc -o test-minus test-minus.c
$ ./test-minus
u1 = 0x18 : 00011000
u1 = 24
u2 = 0xdc : 11011100
u2 = 220
u2 = -36
u3 = 0xf4 : 11110100
u3 = 244
u3 = -12

この通り、u1-u2はu3=244となった。
補数の256を引くとu3=-12となり、24-36=-12という計算が行われている。

# 1-2
このコードでもprint_bit()関数がintで定義されていたがreturnがなかったため、voidに変更した。
また、二つのprintf文を書かなくてもいいようにprint_bit()の始めに以下のコードを追加した。
```
  printf("f = %-12f : ", f);
```

/* test-float.c */
#include <stdio.h>

void print_bit(float f, char name) {
  printf("%c = %-12f : ", name, f);
  int i;
  unsigned int *j = ((unsigned int *)&f);
  unsigned int s = *j;
  for (i = 0; i < 32; i++) {
    printf("%c", ((0x80000000) & s) ? '1' : '0');
    if ((i == 0) || (i == 8))
      printf(" ");
    s = s << 1;
  }
  printf("\n");
}

int main(int argc, char *argv[]) {
  float f; // 32bit, 4byte

  f = 2.5;
  print_bit(f, 'f');

  float a = 2.625;
  print_bit(a, 'a');
  float b = a + a + a;
  print_bit(b, 'b');
  if (b == 7.875f)
    printf("same\n");
  else
    printf("diff\n");

  float g = 0;
  for (int i = 0; i < 1000000; i++) {
    g = g + f;
  }
  print_bit(g, 'g');
}

$ gcc -o test-float test-float.c
$ ./test-float
f = 2.500000     : 0 10000000 01000000000000000000000
a = 2.625000     : 0 10000000 01010000000000000000000
b = 7.875000     : 0 10000001 11111000000000000000000
same
// 結果はsameで、正しく計算されている。
g = 2500000.000000 : 0 10010100 00110001001011010000000
// 期待通りの結果だが......

# 1-3
以下のように、int以外の型に対応した関数を作成。

// test-byteorder.c
#include <stdio.h>

void print_byte_uint(unsigned int s) {
  int i;
  unsigned char *p;
  p = (unsigned char *)&s;
  for (i = 0; i < sizeof(unsigned int); i++) {
    printf("%02x", *p);
    p++;
  }
  printf("\n");
}

void print_byte_ushort(unsigned short s) {
  int i;
  unsigned char *p;
  p = (unsigned char *)&s;
  for (i = 0; i < sizeof(unsigned short); i++) {
    printf("%02x", *p);
    p++;
  }
  printf("\n");
}

void print_byte_ulong(unsigned long s) {
  int i;
  unsigned char *p;
  p = (unsigned char *)&s;
  for (i = 0; i < sizeof(unsigned long); i++) {
    printf("%02x", *p);
    p++;
  }
  printf("\n");
}

int main(int argc, char *argv[]) {
  unsigned int u1; // 32bit, 4byte
  u1 = 0x1234abcd;
  printf("u1 = %x : ", u1);
  print_byte_uint(u1);

  unsigned short u2; // 16bit, 2byte
  u2 = 0x1234;
  printf("u2 = %x : ", u2);
  print_byte_ushort(u2);

  unsigned long u3; // 64bit, 8byte
  u3 = 0x1234abcd5678ef01;
  printf("u3 = %lx : ", u3);
  print_byte_ulong(u3);
}

$ gcc -o test-byteorder test-byteorder.c
$ ./test-byteorder
u1 = 1234abcd : cdab3412
u2 = 1234 : 3412
u3 = 1234abcd5678ef01 : 01ef7856cdab3412

この出力結果から、リトルエンディアンであることがわかる。
